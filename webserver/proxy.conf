############# CONFIG
# configure logs
log_format my_log ' "Request: $Request, Status: $status, Request_uri: $request_uri, Host: $host, Client_IP: $remote_addr, Proxy_IP: $proxy_add_x_forwarded_for, Proxy_Hostname: $proxy_host';

# mapping between file type and expires length for browser caching;
  map $sent_http_content_type $expires {
      default                    off;
      text/html                  epoch;
      text/css                   max;
      application/javascript     max;
      ~image/                    max;
  }
# Host: $upstream, Cache_Status: $upstream_cache_status  "';
  # check tail -f access.log
###################


upstream node {
  server koa:3000;
}

 upstream ruby {
   server ruby:9292;
 }

server {
# when we visit localhost, dc-nginx service has the mapping 8000->80
# since cont-nginx is listening on port 80, it will then..
  listen 8000;
  # root /usr/share/nginx/html;
  # index index.html index.htm index.js;
  
  # server_name localhost;


  # to resolve domain name in runtime, without nginx reload, we can use "resolve" with the address of your actual DNS resolver.
  # the server is, by default, reachable via 127.0.0.11:53
  # Docker network DNS resolver
  # resolver 127.0.0.11.53   valid=1s;
     

  access_log /var/log/nginx/access.log my_log; #<- to watch logs with the output "my_log"

    
  # since we use 2 locations, we must find the static files; we stored them in the container
  # with a bind mount (we should COPY them with Dockerfile). They are in the Nginx container at : /usr/share/nginx/html;
  location ~ \.(png|webp|ico|svg|js)$ {
    root /usr/share/nginx/html;
    add_header Cache-Control "public, no-transform";
    expires   $expires; # read the mapping file/$expires
  }  

  # location / {
  #   try_files $uri $uri/ @node; <- this works with only one @, not 2!!!
  # and then location @node {  proxy_pass htt://node; }
  # }

  # default "/" to node.js. In node, we redirect the route to "/node" where the action is
  location / {
    proxy_pass http://node$request_uri;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_pass_header Authorization;
    # Following is necessary for Websocket support
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
  }

  location /ruby {
    proxy_pass http://ruby$request_uri;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $http_host; # or $host:$server_port; # to preserver href
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_pass_header Authorization;
    # Following is necessary for Websocket support
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
  }
}

